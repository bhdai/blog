<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Bui Huu Dai">
<meta name="dcterms.date" content="2024-08-01">

<title>Sink or Swim: Navigating Deep Learning with the Titanic Competition – Bui Huu Dai</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-6JR4N915S6"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-6JR4N915S6', { 'anonymize_ip': true});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Sink or Swim: Navigating Deep Learning with the Titanic Competition – Bui Huu Dai">
<meta property="og:description" content="Dai’s blog.">
<meta property="og:image" content="https://buidai123.github.io/blog/posts/titanic_competition/titanic.jpg">
<meta property="og:site_name" content="Bui Huu Dai">
<meta name="twitter:title" content="Sink or Swim: Navigating Deep Learning with the Titanic Competition – Bui Huu Dai">
<meta name="twitter:description" content="Dai’s blog.">
<meta name="twitter:image" content="https://buidai123.github.io/blog/posts/titanic_competition/titanic.jpg">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Bui Huu Dai</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/buidai123"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/daibui1234"> <i class="bi bi-twitter-x" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Sink or Swim: Navigating Deep Learning with the Titanic Competition</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">kaggle</div>
                <div class="quarto-category">competition</div>
                <div class="quarto-category">deep learning</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Bui Huu Dai </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 1, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-mission-predict-and-survive" id="toc-the-mission-predict-and-survive" class="nav-link active" data-scroll-target="#the-mission-predict-and-survive">The Mission: Predict and Survive!</a></li>
  <li><a href="#why-the-titanic-its-more-than-just-blockbuster" id="toc-why-the-titanic-its-more-than-just-blockbuster" class="nav-link" data-scroll-target="#why-the-titanic-its-more-than-just-blockbuster">Why the Titanic? It’s More Than Just Blockbuster!</a></li>
  <li><a href="#understand-the-data" id="toc-understand-the-data" class="nav-link" data-scroll-target="#understand-the-data">Understand the Data</a></li>
  <li><a href="#pre-process-data" id="toc-pre-process-data" class="nav-link" data-scroll-target="#pre-process-data">Pre-process Data</a>
  <ul class="collapse">
  <li><a href="#handling-missing-values" id="toc-handling-missing-values" class="nav-link" data-scroll-target="#handling-missing-values">Handling Missing Values</a></li>
  <li><a href="#outlier-detection-and-handling" id="toc-outlier-detection-and-handling" class="nav-link" data-scroll-target="#outlier-detection-and-handling">Outlier Detection and Handling</a></li>
  <li><a href="#feature-engineering" id="toc-feature-engineering" class="nav-link" data-scroll-target="#feature-engineering">Feature Engineering</a></li>
  </ul></li>
  <li><a href="#build-a-deep-learning-model-from-scratch-lets-get-our-hands-dirty" id="toc-build-a-deep-learning-model-from-scratch-lets-get-our-hands-dirty" class="nav-link" data-scroll-target="#build-a-deep-learning-model-from-scratch-lets-get-our-hands-dirty">Build a Deep Learning Model from Scratch: Let’s Get Our Hands Dirty!</a>
  <ul class="collapse">
  <li><a href="#preparing-the-canvas" id="toc-preparing-the-canvas" class="nav-link" data-scroll-target="#preparing-the-canvas">Preparing the Canvas</a></li>
  </ul></li>
  <li><a href="#the-model-architecture-our-neural-blueprint" id="toc-the-model-architecture-our-neural-blueprint" class="nav-link" data-scroll-target="#the-model-architecture-our-neural-blueprint">The Model Architecture: Our Neural Blueprint</a></li>
  <li><a href="#evaluation-and-submission-the-moment-of-truth" id="toc-evaluation-and-submission-the-moment-of-truth" class="nav-link" data-scroll-target="#evaluation-and-submission-the-moment-of-truth">Evaluation and Submission: the Moment of Truth!</a></li>
  <li><a href="#leveling-up-our-neural-network-the-pytorch-edition" id="toc-leveling-up-our-neural-network-the-pytorch-edition" class="nav-link" data-scroll-target="#leveling-up-our-neural-network-the-pytorch-edition">Leveling Up Our Neural Network: The Pytorch Edition!</a>
  <ul class="collapse">
  <li><a href="#training-our-new-model-the-pytorch-way" id="toc-training-our-new-model-the-pytorch-way" class="nav-link" data-scroll-target="#training-our-new-model-the-pytorch-way">Training Our New Model: The Pytorch Way</a></li>
  <li><a href="#what-have-we-learned" id="toc-what-have-we-learned" class="nav-link" data-scroll-target="#what-have-we-learned">What Have We Learned?</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Hey there, data enthusiasts! Today, I’m excited to share my experience with the <a href="https://www.kaggle.com/competitions/titanic">Titanic competition</a> on Kaggle. This challenge has been a fantastic learning opportunity, pushing me to build a deep learning model from scratch.</p>
<p>In this blog post, I’ll walk you through my journey, sharing the ups and downs, the lessons learned, and maybe even a few tips for those of you looking to dive into deep learning yourselves</p>
<section id="the-mission-predict-and-survive" class="level2">
<h2 class="anchored" data-anchor-id="the-mission-predict-and-survive">The Mission: Predict and Survive!</h2>
<p>Alright, here’s the deal: The Titanic competition is like the ultimate “What if?” game. Our mission, should we choose accept it(and we totally should), is to build a machine learning model that can predict whether a passenger survived the Titanic disaster.</p>
<p>Think of it as creating a time-traveling survival predictor:</p>
<ul>
<li>Input: Passenger information</li>
<li>Output: “Survived” or “Didn’t survive”</li>
</ul>
<p>In data science lingo, we’re talking about a binary classification problem. It’s like teaching a computer to sort passenger into two group: the lucky ones who made it, and those who, unfortunately, didn’t.</p>
<p>Now, while many folks tackle this with traditional machine learning methods, we’re going to kick it up a notch. We’ll be diving into the deep en(pun intended) by creating a deep learning model with a neuron network. It’s like giving our computer a super-power brain to solve this historical puzzle!</p>
<p>Why go for a neuron network, you ask? Well, why climb a hill when you can scale a mountain? It’s more complex, sure, but it’s also way more exciting and potentially more powerful. Plus, it’ll give us a taste of the cutting-edge techniques used in modern data science.</p>
<p>So, buckle up (or should i say, put on your life jackets?)! We’re about to embark on a journey that combines historical tragedy, predictive analytics, and the power of deep learning, it’s going to be challenging, it’s going to be insightful, and most importantly, it’s going to be a ton of fun!</p>
<p>Remember, in the world of computer science as well as data science, we’re not just crunching numbers - we’re uncovering stories, solving mysteries, any maybe, just maybe, learning something that could help in the future crises. So let’s dive in and see what secrets the Titanic data set holds for us!</p>
</section>
<section id="why-the-titanic-its-more-than-just-blockbuster" class="level2">
<h2 class="anchored" data-anchor-id="why-the-titanic-its-more-than-just-blockbuster">Why the Titanic? It’s More Than Just Blockbuster!</h2>
<p>You might be wondering, “Why are ew obsessing over a century-old shipwreck?” Well, in the data science world, the Titanic dataset is like that classic book everyone’s read - it’s a rite of passage! Here’s why it’s so awesome for beginners:</p>
<ol type="1">
<li><strong>Data Buffet</strong>: The dataset is a smorgasbord of passenger info. It’s like having a well-stocked pantry - you’ve got everything you need to whip up some tasty insight!</li>
<li><strong>Missing Pieces</strong>: Just like a real-world dataset, it’s got some holes. Time to channle your inner detective and fill into those blanks!</li>
<li><strong>feature Crafting</strong>: Thinking of as data origami - you get to fold and shape new features from the existing ones. It’s where creative meets numbers!</li>
<li><strong>Real Stakes</strong>: This isn’t just some made-up scenario. These were real people on real ship. It adds a whole new levels of meaning to your analysis.</li>
</ol>
</section>
<section id="understand-the-data" class="level2">
<h2 class="anchored" data-anchor-id="understand-the-data">Understand the Data</h2>
<p>the data is splited into two part: the train.csv which is used to train out model, and the test.csv which is for test our model and push the submition into the competition. you can download the dataset manually <a href="https://www.kaggle.com/competitions/3136/download-all">here</a> or set up the kaggle api, you can follow <a href="https://github.com/Kaggle/kaggle-api/blob/main/docs/README.md">this</a> to setup kaggle api then use this command to download the dataset</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kaggle</span> competitions download <span class="at">-c</span> titanic</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>here’s the data dictionary</p>
<table class="table-striped table-hover caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 46%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th>Definition</th>
<th>Key</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>survival</td>
<td>Survival</td>
<td>0 = No, 1 = Yes</td>
</tr>
<tr class="even">
<td>pclass</td>
<td>Ticket class</td>
<td>1 = 1st, 2 = 2nd, 3 = 3rd</td>
</tr>
<tr class="odd">
<td>sex</td>
<td>Sex</td>
<td></td>
</tr>
<tr class="even">
<td>Age</td>
<td>Age in years</td>
<td></td>
</tr>
<tr class="odd">
<td>sibsp</td>
<td># of siblings / spouses aboard the Titanic</td>
<td></td>
</tr>
<tr class="even">
<td>parch</td>
<td># of parents / children aboard the Titanic</td>
<td></td>
</tr>
<tr class="odd">
<td>ticket</td>
<td>Ticket number</td>
<td></td>
</tr>
<tr class="even">
<td>fare</td>
<td>Passenger fare</td>
<td></td>
</tr>
<tr class="odd">
<td>cabin</td>
<td>Cabin number</td>
<td></td>
</tr>
<tr class="even">
<td>embarked</td>
<td>Port of Embarkation</td>
<td>C = Cherbourg, Q = Queenstown, S = Southampton</td>
</tr>
</tbody>
</table>
<div id="cell-4" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Import and read dataset</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch, numpy <span class="im">as</span> np, pandas <span class="im">as</span> pd</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch <span class="im">import</span> tensor</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.nn.functional <span class="im">as</span> F</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.impute <span class="im">import</span> KNNImputer</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">442</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># setup layout option</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>np.printoptions(linewidth<span class="op">=</span><span class="dv">140</span>)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>torch.set_printoptions(linewidth<span class="op">=</span><span class="dv">140</span>, sci_mode<span class="op">=</span><span class="va">False</span>, edgeitems<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>pd.set_option(<span class="st">"display.width"</span>, <span class="dv">140</span>)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> Path(<span class="st">"./input"</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>train_path <span class="op">=</span> path<span class="op">/</span><span class="st">"train.csv"</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>trn_df <span class="op">=</span> pd.read_csv(train_path)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>trn_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="1">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">PassengerId</th>
<th data-quarto-table-cell-role="th">Survived</th>
<th data-quarto-table-cell-role="th">Pclass</th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Sex</th>
<th data-quarto-table-cell-role="th">Age</th>
<th data-quarto-table-cell-role="th">SibSp</th>
<th data-quarto-table-cell-role="th">Parch</th>
<th data-quarto-table-cell-role="th">Ticket</th>
<th data-quarto-table-cell-role="th">Fare</th>
<th data-quarto-table-cell-role="th">Cabin</th>
<th data-quarto-table-cell-role="th">Embarked</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>0</td>
<td>3</td>
<td>Braund, Mr. Owen Harris</td>
<td>male</td>
<td>22.0</td>
<td>1</td>
<td>0</td>
<td>A/5 21171</td>
<td>7.2500</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
<td>female</td>
<td>38.0</td>
<td>1</td>
<td>0</td>
<td>PC 17599</td>
<td>71.2833</td>
<td>C85</td>
<td>C</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>Heikkinen, Miss. Laina</td>
<td>female</td>
<td>26.0</td>
<td>0</td>
<td>0</td>
<td>STON/O2. 3101282</td>
<td>7.9250</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>4</td>
<td>1</td>
<td>1</td>
<td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>
<td>female</td>
<td>35.0</td>
<td>1</td>
<td>0</td>
<td>113803</td>
<td>53.1000</td>
<td>C123</td>
<td>S</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>5</td>
<td>0</td>
<td>3</td>
<td>Allen, Mr. William Henry</td>
<td>male</td>
<td>35.0</td>
<td>0</td>
<td>0</td>
<td>373450</td>
<td>8.0500</td>
<td>NaN</td>
<td>S</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
<section id="pre-process-data" class="level2">
<h2 class="anchored" data-anchor-id="pre-process-data">Pre-process Data</h2>
<p>Alright, folks, let’s dive into the first step of our data adventure: cleaning up our dataset! As we all know, a clean dataset is like a smooth road for our deep learning model to cruise on.</p>
<section id="handling-missing-values" class="level3">
<h3 class="anchored" data-anchor-id="handling-missing-values">Handling Missing Values</h3>
<p>Let’s start by taking a look at our data to see what we’re dealing with:</p>
<div id="cell-6" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>trn_df.isna().<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<pre><code>PassengerId      0
Survived         0
Pclass           0
Name             0
Sex              0
Age            177
SibSp            0
Parch            0
Ticket           0
Fare             0
Cabin          687
Embarked         2
dtype: int64</code></pre>
</div>
</div>
<p>From this, we can see that the <code>Age</code>, and <code>Cabin</code> columns have a lot of missing values. Let’s break down how we’ll handle these</p>
<section id="dealing-with-missing-age-values" class="level4">
<h4 class="anchored" data-anchor-id="dealing-with-missing-age-values">Dealing with Missing Age Values</h4>
<p>First, let’s visualize the distribution of <code>Age</code> to understand it’s importance:</p>
<div id="cell-8" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>sns.displot(trn_df[<span class="st">'Age'</span>], kde<span class="op">=</span><span class="va">False</span>, bins<span class="op">=</span><span class="dv">30</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>As you can see from the plot <code>Age</code> is one of the most crucial features. Younger passengers had a higher chance to survival, while older passenger had a low chance. So, we need to handle <code>Age</code> with extra care.</p>
<p>To fill in the missing <code>Age</code> values, we’ll use the technique called K-Nearest Neighbors(KNN) imputation. Here’s how it works:</p>
<div id="cell-10" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Age imputation</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>age_imputer <span class="op">=</span> KNNImputer(n_neighbors<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">"Age"</span>] <span class="op">=</span> age_imputer.fit_transform(trn_df[[<span class="st">"Age"</span>, <span class="st">"Pclass"</span>, <span class="st">"SibSp"</span>, <span class="st">"Parch"</span>]])[:, <span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here’s the breakdown:</p>
<ul>
<li>We select relevant columns that are likely correlated with <code>Age</code> (<code>Pclass</code>, <code>SibSp</code>, and <code>Parch</code>).</li>
<li>The <code>fit_transform</code> method is called on the <code>age_imputer</code> instance, passing these columns.
<ul>
<li><strong>Fit</strong>: the imputer calculate the distances between rows based on the selected columns and indentifies the 5 nearest neighbors for each instance with with missing <code>Age</code> values.</li>
<li><strong>Transform</strong>: For each missing <code>Age</code> value, the imputer calculate the mean age of the 5 nearest neighbors and fills in the missing value with this mean.</li>
</ul></li>
<li><code>[:, 0]</code> selects the first columns of the resulting array (the imputed <code>Age</code>, values) and assigns it back to the <code>Age</code> columns <code>trn_df</code>.</li>
</ul>
<p>And that’s our K-Nearest Neighbors(KNN) imputation in action!</p>
</section>
<section id="handling-missing-cabin-and-embarked-values" class="level4">
<h4 class="anchored" data-anchor-id="handling-missing-cabin-and-embarked-values">Handling Missing Cabin and Embarked Values</h4>
<p>Now, let’s talk about the <code>Cabin</code> column. This column has lot of missing values. and it doesn’t have a significant impact on survival rates. So, we’ll use a simple approach to fill these missing values:</p>
<div id="cell-12" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>modes <span class="op">=</span> trn_df.mode().iloc[<span class="dv">0</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>trn_df.fillna(modes, inplace<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here, we’re fillng the missing <code>Cabin</code> and two missing <code>Embarded</code> value with the most frequently occurring value (mode). The <code>mode</code> method in Pandas finds the most common value(s) in DataFrame or Series. If multiple modes exist, it return all of them</p>
</section>
</section>
<section id="outlier-detection-and-handling" class="level3">
<h3 class="anchored" data-anchor-id="outlier-detection-and-handling">Outlier Detection and Handling</h3>
<p>Next, let’s inspect the <code>Fare</code> column for any outlier:</p>
<div id="cell-14" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>trn_df.describe(include<span class="op">=</span>np.number)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">PassengerId</th>
<th data-quarto-table-cell-role="th">Survived</th>
<th data-quarto-table-cell-role="th">Pclass</th>
<th data-quarto-table-cell-role="th">Age</th>
<th data-quarto-table-cell-role="th">SibSp</th>
<th data-quarto-table-cell-role="th">Parch</th>
<th data-quarto-table-cell-role="th">Fare</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">count</td>
<td>891.000000</td>
<td>891.000000</td>
<td>891.000000</td>
<td>891.000000</td>
<td>891.000000</td>
<td>891.000000</td>
<td>891.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">mean</td>
<td>446.000000</td>
<td>0.383838</td>
<td>2.308642</td>
<td>29.828249</td>
<td>0.523008</td>
<td>0.381594</td>
<td>32.204208</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">std</td>
<td>257.353842</td>
<td>0.486592</td>
<td>0.836071</td>
<td>13.293378</td>
<td>1.102743</td>
<td>0.806057</td>
<td>49.693429</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">min</td>
<td>1.000000</td>
<td>0.000000</td>
<td>1.000000</td>
<td>0.420000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">25%</td>
<td>223.500000</td>
<td>0.000000</td>
<td>2.000000</td>
<td>22.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>7.910400</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">50%</td>
<td>446.000000</td>
<td>0.000000</td>
<td>3.000000</td>
<td>30.000000</td>
<td>0.000000</td>
<td>0.000000</td>
<td>14.454200</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">75%</td>
<td>668.500000</td>
<td>1.000000</td>
<td>3.000000</td>
<td>35.800000</td>
<td>1.000000</td>
<td>0.000000</td>
<td>31.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">max</td>
<td>891.000000</td>
<td>1.000000</td>
<td>3.000000</td>
<td>80.000000</td>
<td>8.000000</td>
<td>6.000000</td>
<td>512.329200</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>You’ll notice that the mean fare is around 32, but he maximum values is a Whopping 512.3292. Such extreme values can cause issues for our model because they can dominate the results. Let’s visualize this with a histogram:</p>
<div id="cell-16" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">'Fare'</span>].hist()<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>To fix this, we can take the logarithm of the <code>Fare</code> values, which heps to compress the range and make the distribution more reasonable. Since the <code>Fare</code> column contains zeros and <code>log(0)</code> is undefined, we’ll add 1 to all values before applying the logarithm</p>
<div id="cell-18" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">"LogFare"</span>] <span class="op">=</span> np.log1p(trn_df[<span class="st">'Fare'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-19" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">'LogFare'</span>].hist()<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-10-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Alright it’s look better now!</p>
<p>And that’s it for data cleaning! We’ve handled missing values and outliers, setting the stage for effective model training, Next up, we’ll dive into feature engineering, whish is where the fun really begins!</p>
</section>
<section id="feature-engineering" class="level3">
<h3 class="anchored" data-anchor-id="feature-engineering">Feature Engineering</h3>
<p>Alright, buckle up ’cause we’re about to embark on a feature engineering adventure!</p>
<p>First up, we’re gonna create a super coll <code>FamilySize</code> feature. Why? because family matter, especially when you’re trying to survive a shipwreck!</p>
<div id="cell-22" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">"FamilySize"</span>] <span class="op">=</span> trn_df[<span class="st">"SibSp"</span>] <span class="op">+</span> trn_df[<span class="st">"Parch"</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">"IsAlone"</span>] <span class="op">=</span> (trn_df[<span class="st">"FamilySize"</span>] <span class="op">==</span> <span class="dv">1</span>).astype(<span class="bu">int</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, let’s visualize this bad boy:</p>
<div id="cell-24" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>sns.countplot(x<span class="op">=</span><span class="st">'Survived'</span>, data<span class="op">=</span>trn_df, hue<span class="op">=</span><span class="st">'FamilySize'</span>, palette<span class="op">=</span><span class="st">'RdBu_r'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Whoa, check out that plot! It’s like a family reunion, but with survival rates. Looks like having a big family might’ve been a bit of bummer for survival chances. Maybe it was harder to round up the whole crew when things got dicey? On the flip side, small families (up to 4 members) seemed to have better luck. Family-sized life rafts, perhaps?</p>
<p>Next up, we’re gonna play “Name That Title”!</p>
<div id="cell-26" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract title from name</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">'Title'</span>] <span class="op">=</span> trn_df[<span class="st">'Name'</span>].<span class="bu">str</span>.extract(<span class="vs">r' ([A-Za-z]+)\.'</span>, expand<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Group uncommon titles</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>rare_titles <span class="op">=</span> [<span class="st">'Lady'</span>, <span class="st">'Countess'</span>,<span class="st">'Capt'</span>, <span class="st">'Col'</span>, <span class="st">'Don'</span>, <span class="st">'Dr'</span>, <span class="st">'Major'</span>, <span class="st">'Rev'</span>, <span class="st">'Sir'</span>, <span class="st">'Jonkheer'</span>, <span class="st">'Dona'</span>]</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">'Title'</span>] <span class="op">=</span> trn_df[<span class="st">'Title'</span>].replace(rare_titles, <span class="st">'Rare'</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Replace some variations</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">'Title'</span>] <span class="op">=</span> trn_df[<span class="st">'Title'</span>].replace([<span class="st">'Mlle'</span>, <span class="st">'Ms'</span>], <span class="st">'Miss'</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">'Title'</span>] <span class="op">=</span> trn_df[<span class="st">'Title'</span>].replace(<span class="st">'Mme'</span>, <span class="st">'Mrs'</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Mapping</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>title_mapping <span class="op">=</span> {<span class="st">"Mr"</span>: <span class="dv">1</span>, <span class="st">"Miss"</span>: <span class="dv">2</span>, <span class="st">"Mrs"</span>: <span class="dv">3</span>, <span class="st">"Master"</span>: <span class="dv">4</span>, <span class="st">"Rare"</span>: <span class="dv">5</span>}</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">'Title'</span>] <span class="op">=</span> trn_df[<span class="st">'Title'</span>].<span class="bu">map</span>(title_mapping)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We’re extracting titles faster than you can say “I’m the king of the world!” We’ve got our common title, we’re grouping the rare ones(because being a Countess doesn’t help much when the ship’s going down), and we’re doing a little title cleanup.</p>
<p>Now, let’s see what these titles tell us about survival:</p>
<div id="cell-28" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate proportions</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>proportions <span class="op">=</span> trn_df.groupby(<span class="st">'Title'</span>)[<span class="st">'Survived'</span>].value_counts(normalize<span class="op">=</span><span class="va">True</span>).rename(<span class="st">'proportion'</span>).reset_index()</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>sns.barplot(x<span class="op">=</span><span class="st">'Title'</span>, y<span class="op">=</span><span class="st">'proportion'</span>, hue<span class="op">=</span><span class="st">'Survived'</span>, data<span class="op">=</span>proportions)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Survival Rate by Title'</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Title'</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Proportion'</span>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-14-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Holy shipwreck, Batman! look at those survival rates! Poor Mr.1 is going down with the ship, while Mss 2 and Mrs.&nbsp;3 are living the best lifeboat life.</p>
<p>It captures important historical context about the Titanic disaster, particularly the “women and children first” policy during evacuation.</p>
<p>When we use this feature in our model, it should be able to learn these different survival probabilities associated with each title, potentially improving its predictive accuracy.</p>
<p>Next, we’re gonna group these passengers by age</p>
<div id="cell-30" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>trn_df[<span class="st">'AgeBin'</span>] <span class="op">=</span> pd.cut(trn_df[<span class="st">'Age'</span>], bins<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">12</span>, <span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">60</span>, np.inf], labels<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>and for our grand finale, we’re gonna one-hot encode these categorical columns:</p>
<div id="cell-32" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># one hot encode columns</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>trn_df <span class="op">=</span> pd.get_dummies(trn_df, columns<span class="op">=</span>[<span class="st">"Sex"</span>, <span class="st">"Pclass"</span>, <span class="st">"Embarked"</span>, <span class="st">"AgeBin"</span>], drop_first<span class="op">=</span><span class="va">True</span>, dtype<span class="op">=</span><span class="bu">float</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Alright that’s it, let’s write a function to do all of this for the life easier, because we also need to apply it to our test set so that we can make a proper prediction</p>
<div id="cell-34" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> preprocess_data(df):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    age_imputer <span class="op">=</span> KNNImputer(n_neighbors<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"Age"</span>] <span class="op">=</span> age_imputer.fit_transform(df[[<span class="st">"Age"</span>, <span class="st">"Pclass"</span>, <span class="st">"SibSp"</span>, <span class="st">"Parch"</span>]])[:, <span class="dv">0</span>]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    modes <span class="op">=</span> trn_df.mode().iloc[<span class="dv">0</span>]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    trn_df.fillna(modes, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"LogFare"</span>] <span class="op">=</span> np.log1p(df[<span class="st">"Fare"</span>])</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">"FamilySize"</span>] <span class="op">=</span> df[<span class="st">"SibSp"</span>] <span class="op">+</span> df[<span class="st">"Parch"</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'IsAlone'</span>] <span class="op">=</span> (df[<span class="st">'FamilySize'</span>] <span class="op">==</span> <span class="dv">1</span>).astype(<span class="bu">int</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'Title'</span>] <span class="op">=</span> df[<span class="st">'Name'</span>].<span class="bu">str</span>.extract(<span class="vs">r' ([A-Za-z]+)\.'</span>, expand<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    rare_titles <span class="op">=</span> [<span class="st">'Lady'</span>, <span class="st">'Countess'</span>,<span class="st">'Capt'</span>, <span class="st">'Col'</span>, <span class="st">'Don'</span>, <span class="st">'Dr'</span>, <span class="st">'Major'</span>, <span class="st">'Rev'</span>, <span class="st">'Sir'</span>, <span class="st">'Jonkheer'</span>, <span class="st">'Dona'</span>]</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'Title'</span>] <span class="op">=</span> df[<span class="st">'Title'</span>].replace(rare_titles, <span class="st">'Rare'</span>)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'Title'</span>] <span class="op">=</span> df[<span class="st">'Title'</span>].replace([<span class="st">'Mlle'</span>, <span class="st">'Ms'</span>], <span class="st">'Miss'</span>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'Title'</span>] <span class="op">=</span> df[<span class="st">'Title'</span>].replace(<span class="st">'Mme'</span>, <span class="st">'Mrs'</span>)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    title_mapping <span class="op">=</span> {<span class="st">"Mr"</span>: <span class="dv">1</span>, <span class="st">"Miss"</span>: <span class="dv">2</span>, <span class="st">"Mrs"</span>: <span class="dv">3</span>, <span class="st">"Master"</span>: <span class="dv">4</span>, <span class="st">"Rare"</span>: <span class="dv">5</span>}</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'Title'</span>] <span class="op">=</span> df[<span class="st">'Title'</span>].<span class="bu">map</span>(title_mapping)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'AgeBin'</span>] <span class="op">=</span> pd.cut(df[<span class="st">'Age'</span>], bins<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">12</span>, <span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">60</span>, np.inf], labels<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>])</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># One-hot encoding</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.get_dummies(df, columns<span class="op">=</span>[<span class="st">'Sex'</span>, <span class="st">'Pclass'</span>, <span class="st">'Embarked'</span>, <span class="st">'AgeBin'</span>], drop_first<span class="op">=</span><span class="va">True</span>, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, let’s round up our feature posse:</p>
<div id="cell-36" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_columns(name):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [col <span class="cf">for</span> col <span class="kw">in</span> trn_df.columns <span class="cf">if</span> col.startswith(name)]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>added_cols <span class="op">=</span> get_columns((<span class="st">"Sex_"</span>, <span class="st">"Pclass"</span>, <span class="st">"Embarked_"</span>, <span class="st">"AgeBin_"</span>))</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>indep_cols <span class="op">=</span> [<span class="st">'Title'</span>, <span class="st">'Age'</span>, <span class="st">'SibSp'</span>, <span class="st">'Parch'</span>, <span class="st">'LogFare'</span>, <span class="st">'FamilySize'</span>, <span class="st">'IsAlone'</span>] <span class="op">+</span> added_cols</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>t_dep <span class="op">=</span> tensor(trn_df[<span class="st">"Survived"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And there you have it, folks! We’ve engineeried these features faster than the Titanic sank(too soon?). Your models gonna love these new features more than Rose loved Jack. Now go forth and predict those survival rates!</p>
</section>
</section>
<section id="build-a-deep-learning-model-from-scratch-lets-get-our-hands-dirty" class="level2">
<h2 class="anchored" data-anchor-id="build-a-deep-learning-model-from-scratch-lets-get-our-hands-dirty">Build a Deep Learning Model from Scratch: Let’s Get Our Hands Dirty!</h2>
<section id="preparing-the-canvas" class="level3">
<h3 class="anchored" data-anchor-id="preparing-the-canvas">Preparing the Canvas</h3>
<p>Alright, folks! Before we dive into the exciting world of deep learning, we need to prepare our data. It’s like setting up our art studio before creating a masterpiece. Let’s take a look at what we’re working with:</p>
<div id="cell-39" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>t_indep <span class="op">=</span> trn_df[indep_cols].values</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>t_indep</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>array([[ 1. , 22. ,  1. , ...,  1. ,  0. ,  0. ],
       [ 3. , 38. ,  1. , ...,  1. ,  0. ,  0. ],
       [ 2. , 26. ,  0. , ...,  1. ,  0. ,  0. ],
       ...,
       [ 2. , 28.8,  1. , ...,  1. ,  0. ,  0. ],
       [ 1. , 26. ,  0. , ...,  1. ,  0. ,  0. ],
       [ 1. , 32. ,  0. , ...,  1. ,  0. ,  0. ]])</code></pre>
</div>
</div>
<p>Whoa there! If you peek at <code>t_indep</code>, you’ll notice something funky. The age columns is partying way to hard compared to it’s friends. This could through our model for a loop, so let’s calm it down a bit</p>
<p>Now, we could go old school and divide each column by its maximum value. It’s like telling your loudest friend to use their indoor voice. The formula would look something like this:</p>
<p><span class="math inline">\(Normalized\ value = \frac{Feature\ value} {Maximum\ value\ of\ that\ feature}\)</span></p>
<p>But hey, we’re not here to play it safe! We’re going to use a cool trick called StandardScaler. It’s like giving each feature i’s own personal stylist. Here’s the magic behind it:</p>
<p><span class="math inline">\(z = \frac{x - \mu}{\sigma}\)</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(x\)</span> is the original feature value.</li>
<li><span class="math inline">\(\mu\)</span> is the mean of the feature values.</li>
<li><span class="math inline">\(\sigma\)</span> is the standard deviation of the feature values.</li>
<li><span class="math inline">\(z\)</span> is the standardized value.</li>
</ul>
<p>Why StandardScaler, you ask? Well, it’s got some neat perks:</p>
<ol type="1">
<li>It handles outliers like a boss. Max scaling can sometimes squish all your other values when one outliers decides to go crazy.</li>
<li>it’s a gradient descent’s best friend. when you’re dealing with neural networks, having features one a similar scale is like having a smooth road for your optimization on cruise on.</li>
</ol>
<p>Let’s wave our magic wand and see what happens:</p>
<div id="cell-41" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>t_indep <span class="op">=</span> tensor(scaler.fit_transform(t_indep), dtype<span class="op">=</span>torch.<span class="bu">float</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">#dependent variable</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>t_dep <span class="op">=</span> tensor(trn_df[<span class="st">'Survived'</span>].values)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>t_indep</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>tensor([[-0.7076, -0.5892,  0.4328, -0.4737, -0.8797,  0.0592, -1.2316,  ...,  0.9026, -0.3076,  0.6158, -0.3753,  0.7874, -0.4115,
         -0.1591],
        [ 1.2352,  0.6151,  0.4328, -0.4737,  1.3612,  0.0592, -1.2316,  ..., -1.1079, -0.3076, -1.6238, -0.3753,  0.7874, -0.4115,
         -0.1591],
        [ 0.2638, -0.2881, -0.4745, -0.4737, -0.7985, -0.5610,  0.8119,  ...,  0.9026, -0.3076,  0.6158, -0.3753,  0.7874, -0.4115,
         -0.1591],
        [ 1.2352,  0.3893,  0.4328, -0.4737,  1.0620,  0.0592, -1.2316,  ..., -1.1079, -0.3076,  0.6158, -0.3753,  0.7874, -0.4115,
         -0.1591],
        [-0.7076,  0.3893, -0.4745, -0.4737, -0.7842, -0.5610,  0.8119,  ...,  0.9026, -0.3076,  0.6158, -0.3753,  0.7874, -0.4115,
         -0.1591],
        [-0.7076,  0.2312, -0.4745, -0.4737, -0.7386, -0.5610,  0.8119,  ...,  0.9026,  3.2514, -1.6238, -0.3753,  0.7874, -0.4115,
         -0.1591],
        [-0.7076,  1.8194, -0.4745, -0.4737,  1.0381, -0.5610,  0.8119,  ..., -1.1079, -0.3076,  0.6158, -0.3753, -1.2700,  2.4304,
         -0.1591],
        ...,
        [-0.7076, -0.3634, -0.4745, -0.4737, -0.9051, -0.5610,  0.8119,  ...,  0.9026, -0.3076,  0.6158, -0.3753,  0.7874, -0.4115,
         -0.1591],
        [ 1.2352,  0.6903, -0.4745,  5.7328,  0.4575,  2.5397, -1.2316,  ...,  0.9026,  3.2514, -1.6238, -0.3753,  0.7874, -0.4115,
         -0.1591],
        [ 3.1780, -0.2129, -0.4745, -0.4737, -0.3337, -0.5610,  0.8119,  ..., -1.1079, -0.3076,  0.6158, -0.3753,  0.7874, -0.4115,
         -0.1591],
        [ 0.2638, -0.8150, -0.4745, -0.4737,  0.4871, -0.5610,  0.8119,  ..., -1.1079, -0.3076,  0.6158,  2.6646, -1.2700, -0.4115,
         -0.1591],
        [ 0.2638, -0.0774,  0.4328,  2.0089,  0.2420,  1.2994, -1.2316,  ...,  0.9026, -0.3076,  0.6158, -0.3753,  0.7874, -0.4115,
         -0.1591],
        [-0.7076, -0.2881, -0.4745, -0.4737,  0.4871, -0.5610,  0.8119,  ..., -1.1079, -0.3076, -1.6238, -0.3753,  0.7874, -0.4115,
         -0.1591],
        [-0.7076,  0.1635, -0.4745, -0.4737, -0.8190, -0.5610,  0.8119,  ...,  0.9026,  3.2514, -1.6238, -0.3753,  0.7874, -0.4115,
         -0.1591]])</code></pre>
</div>
</div>
<p>Look at that! Our <code>t_indep</code> is now looking sharp and ready for action.</p>
<p>But wait, there’s more! We’re going to split our data into a training set and a validation set. Sure, our dataset might be on the smaller side, but having a validation set is like having a trusty sidekick. It’s helps us keep an eye on our model’s performance and prevents it from getting too cocky (aka overfitting). We’ll use the <code>RandomSplitter</code> in the fastai library to split our dataset</p>
<div id="cell-43" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">442</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastai.data.transforms <span class="im">import</span> RandomSplitter</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>trn_split, val_split <span class="op">=</span> RandomSplitter(seed<span class="op">=</span><span class="dv">42</span>)(trn_df)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>trn_indep, val_indep <span class="op">=</span> t_indep[trn_split], t_indep[val_split]</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>trn_dep, val_dep <span class="op">=</span> t_dep[trn_split], t_dep[val_split]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And there you have it, folks! We’ve got everything we need to start our training montage. Get ready, because we’re about to embark on a wild ride through the world of deep learning. It’s gooing to be a fun one!</p>
</section>
</section>
<section id="the-model-architecture-our-neural-blueprint" class="level2">
<h2 class="anchored" data-anchor-id="the-model-architecture-our-neural-blueprint">The Model Architecture: Our Neural Blueprint</h2>
<p>First things first, let’s create a a function to initialize our coefficients. Think of this as laying the foundation for our neural masterpiece</p>
<div id="cell-46" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> init_coeffs(n_input, n_hidden<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    torch.manual_seed(<span class="dv">442</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    layer_1 <span class="op">=</span> torch.randn(n_input, n_hidden) <span class="op">/</span> np.sqrt(n_input)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    layer_2 <span class="op">=</span> torch.randn(n_hidden, <span class="dv">1</span>) <span class="op">/</span> np.sqrt(n_hidden)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    const <span class="op">=</span> torch.rand(<span class="dv">1</span>)[<span class="dv">0</span>]</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (layer_1.requires_grad_(), layer_2.requires_grad_(), const.requires_grad_())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, you might wondering, “Why only one hidden layer with 10 units?” Well, my friends, sometimes less is more? With a small dataset like Titanic, a simple architecture often works best - compact but effective!</p>
<p>But wait, what’s with tat square root division? Great question! It’s all about keeping our neural network balanced. By dividing by the square root of inputs, we’re making sure our data doesn’t go haywire as it flows through the network. It’s like adding just the right amount of spice to your cooking - not too much - not too little!</p>
<p>Next up, let’s write a function to calculate our predictions:</p>
<div id="cell-48" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_preds(coeffs, indep):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    l1, l2, const <span class="op">=</span> coeffs</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> F.relu(indep <span class="op">@</span> l1) </span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> res<span class="op">@</span>l2 <span class="op">+</span> const</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.sigmoid(res)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is where magic happens! We’re using matrix multiplication (that’s what the <code>@</code> symbol does) and applying our good friend RelLU. Remember our chat about ReLU earlier? This is where it comes into play! If you want to dive deeper into the power of ReLU, check out my previous blog post <a href="https://buidai123.github.io/blog/posts/2024-07-28-from-neuron-to-gradient/#the-magic-of-relus">here</a>.</p>
<p>Now, let’s talk about loss. No, not the kind you feel when MU loses, but the kind that tells use how well our model is doing:</p>
<div id="cell-50" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_loss(coeffs, indeps, deps):</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.<span class="bu">abs</span>(calc_preds(coeffs, indeps)<span class="op">-</span>deps.<span class="bu">float</span>().unsqueeze(<span class="dv">1</span>)).mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We’re using mean absolute error here. It’s like measuring how far off our guess are from the real answers and taking the average. Simple, but effective!</p>
<p>Alright, now for the main event - What happens in one epoch of training:</p>
<div id="cell-52" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> one_epoch(coeffs, lr, batch_size<span class="op">=</span><span class="dv">64</span>):</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(trn_indep)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n, batch_size):</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        batch_indep <span class="op">=</span> trn_indep[i:i<span class="op">+</span>batch_size]</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        batch_dep <span class="op">=</span> trn_dep[i:i<span class="op">+</span>batch_size]</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        loss <span class="op">=</span> calc_loss(coeffs, batch_indep, batch_dep)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>        loss.backward()</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> torch.no_grad():</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> layer <span class="kw">in</span> coeffs:</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>                layer.sub_(layer.grad <span class="op">*</span> lr)</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>                layer.grad.zero_()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This is where we use the mini-batch technique. It’s like learning from a small group of examples at a time instead of trying to memorize the whole text book at one. It’s more efficient and helps our model learn better!</p>
<p>Finally, let’s put it all together in our training function:</p>
<div id="cell-54" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_model(epochs<span class="op">=</span><span class="dv">300</span>, lr<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    torch.manual_seed(<span class="dv">442</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    coeffs <span class="op">=</span> init_coeffs(trn_indep.shape[<span class="dv">1</span>])</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    best_val_loss <span class="op">=</span> <span class="bu">float</span>(<span class="st">"inf"</span>)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    patience <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(epochs):</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>        one_epoch(coeffs, lr)</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> torch.no_grad():</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>            train_loss <span class="op">=</span> calc_loss(coeffs, trn_indep, trn_dep)</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>            val_loss <span class="op">=</span> calc_loss(coeffs, val_indep, val_dep)</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> val_loss <span class="op">&lt;</span> best_val_loss:</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>            best_val_loss <span class="op">=</span> val_loss</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>            best_coeffs <span class="op">=</span> [c.clone() <span class="cf">for</span> c <span class="kw">in</span> coeffs]</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>            counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>            counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> counter <span class="op">&gt;</span> patience:</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Early stopping at epoch </span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> epoch <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Epoch </span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">: Train Loss </span><span class="sc">{</span>train_loss<span class="sc">:.4f}</span><span class="ss">, Val Loss </span><span class="sc">{</span>val_loss<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>        lr <span class="op">*=</span> <span class="fl">0.97</span>  <span class="co"># learning rate schedule</span></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> best_coeffs</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This function is like the conductor of our neural orchestra. It initializes our model, trains it for a number of epochs, and learning rate scheduling (to help our model converge more precisely).</p>
<p>And there you have it, folks! We’ve built a neural network from scratch. It might not look like much, but this little guy is ready to tackle the Titanic competition. In our next post, we’ll put it to the test and see how it performs.</p>
</section>
<section id="evaluation-and-submission-the-moment-of-truth" class="level2">
<h2 class="anchored" data-anchor-id="evaluation-and-submission-the-moment-of-truth">Evaluation and Submission: the Moment of Truth!</h2>
<p>Alright, folks, it’s time to put our homemade neural network to the test! Let’s see how well it can predict who survived the Titanic disaster.</p>
<p>First, we need a way to measure our model’s performance. Here’s our accuracy function:</p>
<div id="cell-57" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluate the model</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> acc(coeffs): </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (val_dep.<span class="bu">bool</span>() <span class="op">==</span> (calc_preds(coeffs, val_indep) <span class="op">&gt;</span> <span class="fl">0.5</span>).squeeze()).<span class="bu">float</span>().mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This function compare our model’s predictions with the actual survival outcomes and calculates the percentage of correct guesses. Simple, but effective!</p>
<p>Now, let’s train our model and see how it performs:</p>
<div id="cell-59" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>coeffs <span class="op">=</span> train_model(epochs<span class="op">=</span><span class="dv">50</span>, lr<span class="op">=</span><span class="dv">1</span>) </span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Validation Accuracy: </span><span class="sc">{</span>acc(coeffs)<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 0: Train Loss 0.3485, Val Loss 0.3620
Epoch 5: Train Loss 0.1921, Val Loss 0.1934
Epoch 10: Train Loss 0.1819, Val Loss 0.1850
Epoch 15: Train Loss 0.1775, Val Loss 0.1805
Epoch 20: Train Loss 0.1739, Val Loss 0.1783
Epoch 25: Train Loss 0.1715, Val Loss 0.1771
Epoch 30: Train Loss 0.1702, Val Loss 0.1759
Epoch 35: Train Loss 0.1693, Val Loss 0.1750
Epoch 40: Train Loss 0.1686, Val Loss 0.1744
Epoch 45: Train Loss 0.1680, Val Loss 0.1741
Validation Accuracy: 0.8315</code></pre>
</div>
</div>
<p>And the results are in!</p>
<p>Well, well, well! look at that! our little neural network is showing some serious potential. We’re seeing the losses decrease over time for both our training and validation sets, which is exactly what we want. It means our model is learning!</p>
<p>And that validation accuracy? 83.15%! Not too shabby for a model we built from scratch, right? In the world of the Titanic competition, that’s a pretty solid score.(not count those who use extra data to train their model, we all know that).</p>
<p>But the real test is yet to come. How will our model perform on the unseen test data? Let’s find out!</p>
<p>After preprocessing our test data(just like we did with our trainding data), we make our predictions:</p>
<div id="cell-61" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Load and preprocess test data</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>test_df <span class="op">=</span> pd.read_csv(path <span class="op">/</span> <span class="st">"test.csv"</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>test_df[<span class="st">'Fare'</span>] <span class="op">=</span> test_df.Fare.fillna(<span class="dv">0</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>test_df <span class="op">=</span> preprocess_data(test_df)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>tst_indep <span class="op">=</span> torch.tensor(test_df[indep_cols].values, dtype<span class="op">=</span>torch.<span class="bu">float</span>)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Scale test data using the same scaler</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>tst_indep <span class="op">=</span> torch.tensor(scaler.transform(tst_indep), dtype<span class="op">=</span>torch.<span class="bu">float</span>)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Make predictions</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>test_df[<span class="st">'Survived'</span>] <span class="op">=</span> (calc_preds(coeffs, tst_indep)<span class="op">&gt;</span><span class="fl">0.5</span>).<span class="bu">int</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s take a quick look at our predictions:</p>
<div id="cell-63" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>sub_df <span class="op">=</span> test_df[[<span class="st">'PassengerId'</span>, <span class="st">'Survived'</span>]]</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sub_df[<span class="st">"Survived"</span>].<span class="bu">sum</span>())</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sub_df[<span class="st">"Survived"</span>].value_counts())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>149
Survived
0    269
1    149
Name: count, dtype: int64</code></pre>
</div>
</div>
<p>Interesting! Our model predicts that 149 passengers survived the Titanic disaster. This about 35.6% of the test set, which is pretty close to the actual survival rate of the Titanic (about 32%). It’s a good sign that our model isn’t wildly off in its predictions.</p>
<p>Now for the moment of truth - submitting to Kaggle!</p>
<p>if you have kaggle api you can use this command</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kaggle</span> competitions submit <span class="at">-c</span> titanic <span class="at">-f</span> sub.csv <span class="at">-m</span> <span class="st">"submit to competition"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>or you can upload the csv file manual in the competition submit page</p>
<p>AFter submitting, we got anaccuracy of 0.77751% on the test set. That’s 77.75% accuracy on unseen data! For a first attempt with a model we built from scratch, that’s pretty impressive. We’re definitely in the right track!</p>
<p>While 77.75% accuracy is great start, there’s always rooms for improvement. Let’s see if we can push our accuracy even higher.</p>
</section>
<section id="leveling-up-our-neural-network-the-pytorch-edition" class="level2">
<h2 class="anchored" data-anchor-id="leveling-up-our-neural-network-the-pytorch-edition">Leveling Up Our Neural Network: The Pytorch Edition!</h2>
<p>Alright, Neural network enthusiasts! We’ve had some success with our homemade model, but now it’s time to kick things up a notch. We’re going to harness the power or Pytorch to create a slightly more sophisticated neural network. Buckle up, because this is where things get exciting!</p>
<p>already let’s write our new architecture.</p>
<div id="cell-67" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SimpleNN(torch.nn.Module):</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, input_size, hidden_size):</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>(SimpleNN, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc1 <span class="op">=</span> torch.nn.Linear(input_size, hidden_size)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bn1 <span class="op">=</span> torch.nn.BatchNorm1d(hidden_size)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc2 <span class="op">=</span> torch.nn.Linear(hidden_size, <span class="dv">1</span>)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> F.relu(<span class="va">self</span>.bn1(<span class="va">self</span>.fc1(x)))</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> torch.sigmoid(<span class="va">self</span>.fc2(x))</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This little beauty is like our previous model’s cooler, more sophisticated cousin. It’s still simple, but it’s packing some extra punch:</p>
<ul>
<li>We’ve got two fully connected layers (<code>fc1</code> and <code>fc2</code>), just like before.</li>
<li>But wait, what’s that <code>bn1</code>? That’s batch normalization layer! it’s like traffic cop for our data, making sure everything flows smoothly between layers.</li>
<li>We’re still using ReLU and sigmoid activations, because hey, if it ain’t broke, don’t fix it!</li>
</ul>
<section id="training-our-new-model-the-pytorch-way" class="level3">
<h3 class="anchored" data-anchor-id="training-our-new-model-the-pytorch-way">Training Our New Model: The Pytorch Way</h3>
<p>Now, let’s look at our sniny new training function:</p>
<div id="cell-69" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_model(model, X_train, y_train, X_val, y_val, epochs<span class="op">=</span><span class="dv">300</span>, lr<span class="op">=</span><span class="fl">0.01</span>, batch_size<span class="op">=</span><span class="dv">32</span>):</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    optimizer <span class="op">=</span> torch.optim.Adam(model.parameters(), lr<span class="op">=</span>lr, weight_decay<span class="op">=</span><span class="fl">0.01</span>)  <span class="co"># L2 regularization</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    scheduler <span class="op">=</span> torch.optim.lr_scheduler.StepLR(optimizer, step_size<span class="op">=</span><span class="dv">50</span>, gamma<span class="op">=</span><span class="fl">0.5</span>)  <span class="co"># Step LR schedule</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    best_val_loss <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    patience <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(epochs):</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>        model.train()</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(X_train), batch_size):</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>            batch_X <span class="op">=</span> X_train[i:i<span class="op">+</span>batch_size]</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>            batch_y <span class="op">=</span> y_train[i:i<span class="op">+</span>batch_size]</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>            optimizer.zero_grad()</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>            outputs <span class="op">=</span> model(batch_X)</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>            loss <span class="op">=</span> F.binary_cross_entropy(outputs, batch_y.unsqueeze(<span class="dv">1</span>))</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>            loss.backward()</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>            optimizer.step()</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>        scheduler.step()</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>        model.<span class="bu">eval</span>()</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> torch.no_grad():</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>            val_outputs <span class="op">=</span> model(X_val)</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>            val_loss <span class="op">=</span> F.binary_cross_entropy(val_outputs, y_val.unsqueeze(<span class="dv">1</span>))</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> val_loss <span class="op">&lt;</span> best_val_loss:</span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>            best_val_loss <span class="op">=</span> val_loss</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>            best_model <span class="op">=</span> model.state_dict()</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>            counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>            counter <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> counter <span class="op">&gt;</span> patience:</span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Early stopping at epoch </span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> epoch <span class="op">%</span> <span class="dv">10</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Epoch </span><span class="sc">{</span>epoch<span class="sc">}</span><span class="ss">: Train Loss </span><span class="sc">{</span>loss<span class="sc">.</span>item()<span class="sc">:.4f}</span><span class="ss">, Val Loss </span><span class="sc">{</span>val_loss<span class="sc">.</span>item()<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a>    model.load_state_dict(best_model)</span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This function is like a personal trainer for our model. Here’s what’s new:</p>
<ul>
<li>We’re using Adam optimizer - it’s like giving our model a smart personal coach that adapts the trainign intensity for each parameter and ’cause this post is a bit too long so i think i will explain Adam optimizer in the different blog post.</li>
<li>We’ve added a learning rate scheduler. It’s like adjusting the difficulty of our model’s workout every 50 epochs. Maybe i’ll explain this in another blog post too, it worth an blog post to talk about this.</li>
<li>We’re using binary cross-entropy loss now, which is perfect for our binary classification problem.</li>
</ul>
<p>Now, we have the forward pass:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>optimizer.zero_grad()</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>outputs <span class="op">=</span> model(batch_X)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>loss <span class="op">=</span> F.binary_cross_entropy(outputs, batch_y.unsqueeze(<span class="dv">1</span>))</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>loss.backward()</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>optimizer.step()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is where the real learning happens:</p>
<ol type="1">
<li><p>We clear out any leftover gradients with <code>optimizer.zero_grad()</code>. It’s like wiping the whiteboard clean before a new lesson.</p></li>
<li><p><code>outputs = model(batch_X)</code> it our model making it’s best guess based on what it know so far.</p></li>
<li><p>We calculate how wrong we were with <code>loss = F.binary_cross_entropy(...)</code>. this is like getting our test results back</p></li>
<li><p>Finally, <code>optimizer.step()</code> applies these adjustments. it’s like making notes on how to improve for the next test</p></li>
</ol>
<p>After each epoch, we adjust our learning rate:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>scheduler.step()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>this is like adjusting the difficulty as we get better. We don’t want things to be too easy or too hard!</p>
<p>Lastly, we check how we’re doing on the validation set:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>model.<span class="bu">eval</span>()</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    val_outputs <span class="op">=</span> model(X_val)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    val_loss <span class="op">=</span> F.binary_cross_entropy(val_outputs, y_val.unsqueeze(<span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>this is just as before so nothing to explain here alright</p>
<p>alright let’s put our new model through it’s paces:</p>
<div id="cell-71" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Prepare the data</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> scaler.fit_transform(trn_df[indep_cols].values)</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> trn_df[<span class="st">'Survived'</span>].values</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>X_train, X_val, y_train, y_val <span class="op">=</span> train_test_split(X, y, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>X_train <span class="op">=</span> torch.FloatTensor(X_train)</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>y_train <span class="op">=</span> torch.FloatTensor(y_train)</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>X_val <span class="op">=</span> torch.FloatTensor(X_val)</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>y_val <span class="op">=</span> torch.FloatTensor(y_val)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize and train the model</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>input_size <span class="op">=</span> X_train.shape[<span class="dv">1</span>]</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>hidden_size <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> SimpleNN(input_size, hidden_size)</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>trained_model <span class="op">=</span> train_model(model, X_train, y_train, X_val, y_val, epochs<span class="op">=</span><span class="dv">50</span>, lr<span class="op">=</span><span class="fl">0.02</span>)</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluate the model</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>model.<span class="bu">eval</span>()</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>    val_outputs <span class="op">=</span> model(X_val)</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>    val_preds <span class="op">=</span> (val_outputs <span class="op">&gt;</span> <span class="fl">0.5</span>).<span class="bu">float</span>()</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>    accuracy <span class="op">=</span> (val_preds.squeeze() <span class="op">==</span> y_val).<span class="bu">float</span>().mean()</span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Validation Accuracy: </span><span class="sc">{</span>accuracy<span class="sc">.</span>item()<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch 0: Train Loss 0.3662, Val Loss 0.4901
Epoch 10: Train Loss 0.2244, Val Loss 0.4254
Epoch 20: Train Loss 0.2155, Val Loss 0.4271
Early stopping at epoch 29
Validation Accuracy: 0.8268</code></pre>
</div>
</div>
<p>Our model decided to call it quits after just 29 epochs. Our validation accuracy is …82.68%? That’s actually a bit lower that our previous model. But don’t panic! Sometimes, a slightly lower validation accuracy can lead to better performance on unseen data. It’s like how sometimes taking it easyy in practice can lead to better performance in the big game.</p>
<p>alright let submit to kaggle to see how our model performs on test set, shall we!</p>
<div id="cell-73" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Load and preprocess test data</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>test_df <span class="op">=</span> pd.read_csv(path <span class="op">/</span> <span class="st">"test.csv"</span>)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>test_df <span class="op">=</span> preprocess_data(test_df)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Ensure test_df has all the necessary columns</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> indep_cols:</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> test_df.columns:</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>        test_df[col] <span class="op">=</span> <span class="dv">0</span>  <span class="co"># or some appropriate default value</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> test_df[indep_cols].values</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> scaler.transform(X_test)</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> torch.FloatTensor(X_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>i just did as before</p>
<div id="cell-75" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Make predictions on test set</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>model.<span class="bu">eval</span>()</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> torch.no_grad():</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    test_outputs <span class="op">=</span> model(X_test)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    test_preds <span class="op">=</span> (test_outputs <span class="op">&gt;</span> <span class="fl">0.5</span>).<span class="bu">int</span>()</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>test_df[<span class="st">"Survived"</span>] <span class="op">=</span> test_preds</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>same thing here</p>
<div id="cell-77" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>sub_df <span class="op">=</span> test_df[[<span class="st">'PassengerId'</span>, <span class="st">'Survived'</span>]]</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sub_df[<span class="st">"Survived"</span>].<span class="bu">sum</span>())</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sub_df[<span class="st">"Survived"</span>].value_counts())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>149
Survived
0    269
1    149
Name: count, dtype: int64</code></pre>
</div>
</div>
<p>alright everythig seems good till now, let’s make our submit shall we?</p>
<div id="cell-79" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>sub_df.to_csv(<span class="st">"sub_ver3.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-80" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>head sub_ver3.csv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>PassengerId,Survived
892,0
893,0
894,0
895,0
896,1
897,0
898,1
899,0
900,1</code></pre>
</div>
</div>
<p>alright in the time i write this blog post i got this result <img src="./the_best.png" style="width:100%;"></p>
<p>we got an accuracy of 0.78708! That’s 78.71%, which is a solid improvement over our previous score of 77.51%. We’ve climbed another rung on the Kaggle leaderboard ladder!</p>
</section>
<section id="what-have-we-learned" class="level3">
<h3 class="anchored" data-anchor-id="what-have-we-learned">What Have We Learned?</h3>
<ol type="1">
<li><p>Sometimes, a more complex model (like our PyTorch version) can lead to better generalization, even if the validation accuracy is slightly lower.</p></li>
<li><p>Early stopping can prevent overfitting - our model knew when to quit while it was ahead.</p></li>
<li><p>Consistency in predictions (149 survivors in both models) suggests we’re on the right track.</p></li>
</ol>
<p>Remember, in the world of machine learning as well as deep learning, there’s always room for improvement. So keep experimenting, keep learning, and who knows? Maybe you’ll be the one to finally crack the Titanic code and reach that coveted top spot on the Kaggle leaderboard!</p>
<p>Until next time, happy modeling, and may the gradients be ever in your favor!</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/buidai123\.github\.io\/blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="buidai123/buidai123.github.io.comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 Copyright 2024, Bui Huu Dai
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>